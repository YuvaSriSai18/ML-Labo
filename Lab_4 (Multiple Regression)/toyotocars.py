# -*- coding: utf-8 -*-
"""ToyotoCars.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1USevo3wUWqpVhPY_kgqmNGL4QkGOjl4F
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Load the dataset
df = pd.read_csv('./ToyotaCorolla.csv')

# Display dataset columns
print("Dataset columns:", df.columns)

# Selecting the relevant columns
df = df[["Price", "Age_08_04", "KM", "HP", "cc", "Doors", "Gears", "Quarterly_Tax", "Weight"]]

# Display first few rows
print("First few rows of the dataset:")
print(df.head())

# Plot correlation heatmap
corr_results = df.corr()
fig = plt.figure(figsize=(12, 7))
sns.heatmap(corr_results, annot=True, cmap="coolwarm")
plt.title('Correlation Matrix')
plt.show()

# Splitting the data into features (X) and target (y)
X = df.iloc[:, 1:].values  # Features
y = df.iloc[:, 0].values  # Target (Price)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)

print("Shape of X_train:", X_train.shape)
print("Shape of X_test:", X_test.shape)
print("Shape of y_train:", y_train.shape)
print("Shape of y_test:", y_test.shape)

# Standardizing the features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Linear Regression
regressor = LinearRegression()
regressor.fit(X_train, y_train)

# Predicting the Test set results
y_pred = regressor.predict(X_test)

# Evaluating the model
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)
accuracy = 1 - mse / y_test.var()

print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"R-squared (RÂ²): {r2:.2f}")
print(f"Accuracy: {accuracy:.2f}")

# Comparison of predicted vs actual values
comparison = np.concatenate((y_pred.reshape(len(y_pred), 1), y_test.reshape(len(y_test), 1)), axis=1)
print("Comparison of predicted vs actual values:")
print(comparison)

def calculate_mse_r2(y_test, y_predict):
    # Convert inputs to numpy arrays
    y_test = np.array(y_test)
    y_predict = np.array(y_predict)

    mse = np.mean((y_test - y_predict) ** 2)
    ss_total = np.sum((y_test - np.mean(y_test)) ** 2)
    ss_residual = np.sum((y_test - y_predict) ** 2)
    r2 = 1 - (ss_residual / ss_total)

    return mse, r2

mse_manual, r2_manual = calculate_mse_r2(y_test, y_pred)
print(f"Manual Mean Squared Error: {mse_manual:.2f}")
print(f"Manual R-squared: {r2_manual:.2f}")